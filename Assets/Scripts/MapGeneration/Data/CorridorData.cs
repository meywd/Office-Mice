using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using OfficeMice.MapGeneration.Validation;

namespace OfficeMice.MapGeneration.Data
{
    /// <summary>
    /// Represents a corridor connecting two rooms.
    /// Corridors are generated by pathfinding between room doorways.
    /// </summary>
    [Serializable]
    public class CorridorData
    {
        [Header("Identity")]
        [SerializeField] private int _corridorID;

        [Header("Connectivity")]
        [SerializeField] private int _roomA_ID;
        [SerializeField] private int _roomB_ID;
        [SerializeField] private Vector2Int _startPosition; // Doorway position in Room A
        [SerializeField] private Vector2Int _endPosition;   // Doorway position in Room B

        [Header("Path Data")]
        [SerializeField] private List<Vector2Int> _pathTiles; // All tiles in corridor
        [SerializeField] private int _width; // Corridor width in tiles (typically 3)
        [SerializeField] private int _length; // Cached: _pathTiles.Count

        [Header("Properties")]
        [SerializeField] private CorridorShape _shape; // Straight, L-shaped, Z-shaped

        // Public Properties
        public int CorridorID
        {
            get => _corridorID;
            set => _corridorID = value;
        }

        public int RoomA_ID => _roomA_ID;
        public int RoomB_ID => _roomB_ID;
        public Vector2Int StartPosition => _startPosition;
        public Vector2Int EndPosition => _endPosition;
        public IReadOnlyList<Vector2Int> PathTiles => _pathTiles.AsReadOnly();
        public int Width => _width;
        public int Length => _length;
        public CorridorShape Shape => _shape;

        // Constructor
        public CorridorData(int roomA, int roomB, Vector2Int start, Vector2Int end, int width = 3)
        {
            _roomA_ID = roomA;
            _roomB_ID = roomB;
            _startPosition = start;
            _endPosition = end;
            _width = Mathf.Clamp(width, 1, 5); // Allow 1-5 tile width
            _pathTiles = new List<Vector2Int>();
            _length = 0;
            _shape = CorridorShape.Point;
        }

        // Mutators
        public void SetPath(List<Vector2Int> path)
        {
            if (path == null || path.Count == 0)
            {
                Debug.LogWarning($"Corridor {_corridorID}: Attempted to set empty path");
                return;
            }

            _pathTiles = new List<Vector2Int>(path);
            _length = _pathTiles.Count;
            _shape = DetermineShape(path);
        }

        public void SetWidth(int width)
        {
            _width = Mathf.Clamp(width, 1, 5);
        }

        public void AddPathTile(Vector2Int tile)
        {
            if (!_pathTiles.Contains(tile))
            {
                _pathTiles.Add(tile);
                _length = _pathTiles.Count;
                _shape = DetermineShape(_pathTiles);
            }
        }

        public void RemovePathTile(Vector2Int tile)
        {
            if (_pathTiles.Remove(tile))
            {
                _length = _pathTiles.Count;
                _shape = DetermineShape(_pathTiles);
            }
        }

        public void ClearPath()
        {
            _pathTiles.Clear();
            _length = 0;
            _shape = CorridorShape.Point;
        }

        // Query Methods
        public bool ConnectsRoom(int roomID)
        {
            return _roomA_ID == roomID || _roomB_ID == roomID;
        }

        public int GetOtherRoomID(int roomID)
        {
            if (roomID == _roomA_ID) return _roomB_ID;
            if (roomID == _roomB_ID) return _roomA_ID;
            return -1; // Not connected
        }

        public bool ContainsTile(Vector2Int tile)
        {
            return _pathTiles.Contains(tile);
        }

        public Vector2Int GetStartTile()
        {
            return _pathTiles.Count > 0 ? _pathTiles[0] : Vector2Int.zero;
        }

        public Vector2Int GetEndTile()
        {
            return _pathTiles.Count > 0 ? _pathTiles[_pathTiles.Count - 1] : Vector2Int.zero;
        }

        public Vector2Int GetCenterTile()
        {
            if (_pathTiles.Count == 0) return Vector2Int.zero;
            int centerIndex = _pathTiles.Count / 2;
            return _pathTiles[centerIndex];
        }

        public RectInt GetBounds()
        {
            if (_pathTiles.Count == 0) return new RectInt();

            int minX = _pathTiles.Min(t => t.x);
            int maxX = _pathTiles.Max(t => t.x);
            int minY = _pathTiles.Min(t => t.y);
            int maxY = _pathTiles.Max(t => t.y);

            return new RectInt(minX, minY, maxX - minX + 1, maxY - minY + 1);
        }

        public bool IsStraight()
        {
            return _shape == CorridorShape.Straight;
        }

        public bool IsLShaped()
        {
            return _shape == CorridorShape.L_Shaped;
        }

        public bool IsZShaped()
        {
            return _shape == CorridorShape.Z_Shaped;
        }

        public bool IsComplex()
        {
            return _shape == CorridorShape.Complex;
        }

        // Shape Detection
        private CorridorShape DetermineShape(List<Vector2Int> path)
        {
            if (path == null || path.Count < 2)
                return CorridorShape.Point;

            // Check if all tiles are collinear
            bool allHorizontal = true;
            bool allVertical = true;

            for (int i = 1; i < path.Count; i++)
            {
                if (path[i].y != path[0].y)
                    allHorizontal = false;
                if (path[i].x != path[0].x)
                    allVertical = false;
            }

            if (allHorizontal || allVertical)
                return CorridorShape.Straight;

            // Count direction changes
            int directionChanges = 0;
            for (int i = 2; i < path.Count; i++)
            {
                Vector2Int dir1 = path[i - 1] - path[i - 2];
                Vector2Int dir2 = path[i] - path[i - 1];
                if (dir1 != dir2)
                    directionChanges++;
            }

            if (directionChanges == 1)
                return CorridorShape.L_Shaped;
            else if (directionChanges == 2)
                return CorridorShape.Z_Shaped;
            else
                return CorridorShape.Complex;
        }

        // Geometric Operations
        public List<Vector2Int> GetExpandedTiles(int expansionWidth)
        {
            var expandedTiles = new List<Vector2Int>();
            
            foreach (var tile in _pathTiles)
            {
                // Add tiles in a square around each path tile
                for (int dx = -expansionWidth; dx <= expansionWidth; dx++)
                {
                    for (int dy = -expansionWidth; dy <= expansionWidth; dy++)
                    {
                        Vector2Int expandedTile = tile + new Vector2Int(dx, dy);
                        if (!expandedTiles.Contains(expandedTile))
                            expandedTiles.Add(expandedTile);
                    }
                }
            }

            return expandedTiles;
        }

        public float GetDistance()
        {
            if (_pathTiles.Count < 2) return 0f;
            
            float distance = 0f;
            for (int i = 1; i < _pathTiles.Count; i++)
            {
                distance += Vector2Int.Distance(_pathTiles[i - 1], _pathTiles[i]);
            }
            return distance;
        }

        // Validation
        public ValidationResult Validate()
        {
            var result = new ValidationResult();

            // Validate basic properties
            if (_corridorID < 0)
                result.AddError($"Corridor has invalid ID: {_corridorID}");

            if (_roomA_ID < 0 || _roomB_ID < 0)
                result.AddError($"Corridor {_corridorID} has invalid room IDs: {_roomA_ID}, {_roomB_ID}");

            if (_roomA_ID == _roomB_ID)
                result.AddError($"Corridor {_corridorID} connects room to itself: {_roomA_ID}");

            // Validate positions
            if (_startPosition == _endPosition)
                result.AddWarning($"Corridor {_corridorID} has same start and end position: {_startPosition}");

            // Validate path
            if (_pathTiles.Count == 0)
                result.AddError($"Corridor {_corridorID} has no path tiles");

            if (_pathTiles.Count > 0)
            {
                // Check if path contains start and end positions
                if (!_pathTiles.Contains(_startPosition))
                    result.AddError($"Corridor {_corridorID} path doesn't contain start position {_startPosition}");

                if (!_pathTiles.Contains(_endPosition))
                    result.AddError($"Corridor {_corridorID} path doesn't contain end position {_endPosition}");

                // Check for duplicate tiles
                var uniqueTiles = new HashSet<Vector2Int>(_pathTiles);
                if (uniqueTiles.Count != _pathTiles.Count)
                    result.AddWarning($"Corridor {_corridorID} path contains duplicate tiles");

                // Check path continuity
                for (int i = 1; i < _pathTiles.Count; i++)
                {
                    Vector2Int diff = _pathTiles[i] - _pathTiles[i - 1];
                    float distance = Mathf.Abs(diff.x) + Mathf.Abs(diff.y); // Manhattan distance
                    
                    if (distance > 1)
                    {
                        result.AddError($"Corridor {_corridorID} path has gap between tiles {_pathTiles[i - 1]} and {_pathTiles[i]}");
                        break;
                    }
                }
            }

            // Validate width
            if (_width < 1)
                result.AddError($"Corridor {_corridorID} has invalid width: {_width}");

            if (_width < 3)
                result.AddWarning($"Corridor {_corridorID} is narrow (width: {_width}), may cause NavMesh gaps");

            // Validate length
            if (_length != _pathTiles.Count)
                result.AddError($"Corridor {_corridorID} length mismatch: cached {_length}, actual {_pathTiles.Count}");

            // Validate shape consistency
            CorridorShape expectedShape = DetermineShape(_pathTiles);
            if (_shape != expectedShape)
                result.AddWarning($"Corridor {_corridorID} shape mismatch: cached {_shape}, calculated {expectedShape}");

            return result;
        }

        // Utility Methods
        public CorridorData Clone()
        {
            var clone = new CorridorData(_roomA_ID, _roomB_ID, _startPosition, _endPosition, _width);
            clone._corridorID = _corridorID;
            clone.SetPath(_pathTiles);
            return clone;
        }

        public void Reverse()
        {
            // Swap room IDs and positions
            int tempRoomID = _roomA_ID;
            _roomA_ID = _roomB_ID;
            _roomB_ID = tempRoomID;

            Vector2Int tempPos = _startPosition;
            _startPosition = _endPosition;
            _endPosition = tempPos;

            // Reverse path
            _pathTiles.Reverse();
        }

        public override string ToString()
        {
            return $"Corridor[{_corridorID}] Room{_roomA_ID}<->Room{_roomB_ID} ({_shape}) - {_length} tiles, width:{_width}";
        }

        public override bool Equals(object obj)
        {
            if (obj is CorridorData other)
            {
                return _corridorID == other._corridorID;
            }
            return false;
        }

        public override int GetHashCode()
        {
            return _corridorID.GetHashCode();
        }
    }
}